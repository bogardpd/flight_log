# Controls {Route} pages and actions.
#
# Note that this specifically refers to flight routes, and not routes in the
# Ruby on Rails routing sense.
#
# The {Route} model is largely used to maintain a table of route distances
# between {Airport} pairs; most interaction that the application has with a
# {Route} is actually internally managed as the pair of {Airport Airports}
# associated with a {Flight}.
#
# The #new and #create actions are not provided because {Route Routes} are not
# created manually; instead, they are automatically created when
# {Route.distance_by_airport} is called by any view needing the distance of a
# {Route} that hasn't been created yet, or when a verified user navigates to
# {#edit} from the {#show} view. (Since the {#show} action is defined by two
# {Airport} parameters rather than a {Route} parameter, it can show a {Route}
# which does not yet exist in the database.)
#
# Likewise, a #destroy action is not provided because maintaining the route
# distance saves a {AeroAPI4} distance lookup in the future if a flight is
# ever added with this route. {#index} generates its {Route} list from {Flight}
# {Airport} pairs rather than just querying the {Route} model, so unused routes
# won't be seen.
class RoutesController < ApplicationController
  before_action :logged_in_user, :only => [:new, :create, :edit, :update, :destroy]
  
  # Shows a table of all {Route Routes} flown. Note that this list of routes is
  # generated by looking at the {Airport} pairs associated with the list of
  # {Flight Flights}, rather than querying the {Route} model.
  #
  # @return [nil]
  def index
        
    flights = flyer.flights(current_user)
    @sort = Table.sort_parse(params[:sort], :flights, :desc)
    @route_table = Route.flight_table_data(flights, *@sort)     
    
    if @route_table.size > 0
      
      # Find maxima for graph scaling:
      @flights_maximum = @route_table.max_by{|i| i[:flight_count].to_i}[:flight_count]
      @distance_maximum = @route_table.max_by{|i| i[:distance_mi].to_i}[:distance_mi]
  
    end
    
  end
  
  # Shows details for a particular {Route} and data for all {Flight Flights}
  # which use it.
  # 
  # Note that this is not directly showing an instance of the {Route} model,
  # but instead takes two {Airport Airports} as parameters. This allows the
  # application to show details for flights involving a certain {Airport} pair,
  # whether or not a {Route} has been created for it. However, if the
  # appropriate {Route} exists, its distance will be used in this view.
  # 
  # {Route} details:
  # * a {SingleFlightMap}
  # * the distance
  # 
  # {Flight} data:
  # * a table of {Flight Flights}
  # * the total distance flown
  # * a table of {TripsController#show_section trip sections} using this route with a {HighlightedRoutesMap} of all {Flight Flights} in those sections
  # * a table of {Trip Trips} using this route with a {HighlightedRoutesMap} of all {Flight Flights} in those trips
  # * a table of {Airline Airlines}
  # * a table of {AirlinesController#show_operator operators}
  # * a table of {AircraftFamily AircraftFamilies}
  # * a table of {FlightsController#show_class classes}
  # * the longest and shortest {Flight}
  #
  # @return [nil]
  def show
    @airports = Array.new
    
    @airports.push(Airport.find_by(slug: params[:airport1]))
    @airports.push(Airport.find_by(slug: params[:airport2]))
    raise ActiveRecord::RecordNotFound if @airports.first == nil || @airports.last == nil
    
    @route_with_arrow = Route.airport_string(*@airports, sort: false)
    
    @logo_used = true

    flyer_flights = flyer.flights(current_user).includes(:airline, :origin_airport, :destination_airport, :trip)
    @flights = flyer_flights.where("(origin_airport_id = :city1 AND destination_airport_id = :city2) OR (origin_airport_id = :city2 AND destination_airport_id = :city1)", {city1: @airports[0].id, city2: @airports[1].id})
    
    raise ActiveRecord::RecordNotFound if @flights.length == 0
    
    # Determine trips and sections:
    @pair_distance = Route.distance_by_airport(@airports[0],@airports[1])
    @trips_and_sections = Trip.matching_trips_and_sections(@flights)
    
    # Create comparitive lists of airlines, aircraft, and classes:
    @airlines = Airline.flight_table_data(@flights, type: :airline)
    @operators = Airline.flight_table_data(@flights, type: :operator)
    @aircraft_families = AircraftFamily.flight_table_data(@flights)
    @classes = TravelClass.flight_table_data(@flights)
    
    # Create flight arrays for maps of trips and sections:
    @city_pair_trip_flights    = flyer_flights.where(trip_id: @trips_and_sections.map{|t| t[:trip_id]})
    @city_pair_section_flights = flyer_flights.where(Trip.section_where_array(@trips_and_sections))
    
    # Create maps:
    @maps = {
      route_map:    SingleFlightMap.new(:route_map, @flights.first),
      sections_map: HighlightedRoutesMap.new(:sections_map, @city_pair_section_flights, @flights),
      trips_map:    HighlightedRoutesMap.new(:trips_map, @city_pair_trip_flights, @flights),
    }
    render_map_extension(@maps, params[:map_id], params[:extension])
    
  rescue ActiveRecord::RecordNotFound
    flash[:warning] = %Q(We couldnʼt find any flights with the route <span class="param-highlight">#{params[:airport1]} &ndash; #{params[:airport2]}</span>. Instead, weʼll give you a list of routes.)
    redirect_to routes_path
    
  end
  
  # Shows a form to edit {Route} distance.
  #
  # This action can only be performed by a verified user.
  #
  # @return [nil]
  def edit
    @airport_ids = [params[:airport1],params[:airport2]]
    @airports = Array.new
    @airports.push(Airport.find(@airport_ids.first))
    @airports.push(Airport.find(@airport_ids.last))
    @airports.sort_by{|a| a.slug}
    
    @airport_ids.sort! # Ensure IDs are in order
    
    # Check to see if route already exists in database. If so, edit it, if not, new route.
    current_route = Route.where("(airport1_id = ? AND airport2_id = ?) OR (airport1_id = ? AND airport2_id = ?)", @airport_ids[0], @airport_ids[1], @airport_ids[1], @airport_ids[0])
    if current_route.present?
      # Route exists, edit it.
      @route = current_route.first
      
    else
      # Route does not exist, create a new one.
      @route = Route.new
    end
    
  rescue ArgumentError
    flash[:warning] = "Canʼt look up route - at least one of these airports does not exist in the database."
    redirect_to routes_path
    
  end
  
  # Updates an existing {Route}.
  #
  # This action can only be performed by a verified user.
  #
  # @return [nil]
  def update
    @route = Route.find(params[:id])
    if @route.update(route_params)
      flash[:success] = "Successfully updated route distance."
      redirect_to show_route_path(airport1: @route.airport1.slug, airport2: @route.airport2.slug)
    else
      render "edit"
    end
  end
  
  private

  # Defines permitted {Airport} parameters.
  #
  # @return [ActionController::Parameters]
  def route_params
    params.require(:route).permit(:airport1_id, :airport2_id, :distance_mi)
  end

end
  
